<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>joshua poehls | silent thought</title>
    <link>http://joshua.poehls.me/tags/golang/</link>
    <language>en-us</language>
    <author>Joshua Poehls</author>
    <copyright>Copyright (c) 2014-2015 Joshua Poehls. All rights reserved.</copyright>
    <updated>Sat, 14 Mar 2015 10:43:31 -0600</updated>
    
    <item>
      <title>Reading Day One journals in Go</title>
      <link>http://joshua.poehls.me/2015/03/dayone-golang-package</link>
      <pubDate>Sat, 14 Mar 2015 10:43:31 -0600</pubDate>
      <author>Joshua Poehls</author>
      <guid>http://joshua.poehls.me/2015/03/dayone-golang-package</guid>
      <description>&lt;p&gt;Here&amp;rsquo;s a little gift for my fellow &lt;a href=&#34;http://dayoneapp.com&#34;&gt;Day One&lt;/a&gt; aficionados who also happen to use &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Go package for reading Day One journal files!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;#11089; &lt;a href=&#34;http://github.com/jpoehls/go-dayone&#34;&gt;Source&lt;/a&gt;
&amp;nbsp;
&amp;#11089; &lt;a href=&#34;http://godoc.org/github.com/jpoehls/go-dayone&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s as easy as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;github.com/jpoehls/go-dayone&amp;quot;

j := dayone.NewJournal(&amp;quot;/Users/{me}/Dropbox/Apps/Day One/Journal.dayone&amp;quot;)

err := j.Read(func(e *Entry, err error) error {
	if err != nil {
		return err
	}

	// Do something with the entry,
	// or return dayone.ErrStopRead to break.
})

if err != nil {
	panic(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d like to add support for creating and editing entries in the future. Contributions welcome, just hit me up!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go 101: String or Byte Slice?</title>
      <link>http://joshua.poehls.me/2014/04/go-101-string-or-byte-slice</link>
      <pubDate>Wed, 16 Apr 2014 09:58:59 CDT</pubDate>
      <author>Joshua Poehls</author>
      <guid>http://joshua.poehls.me/2014/04/go-101-string-or-byte-slice</guid>
      <description>

&lt;p&gt;One of the first things you&amp;rsquo;ll notice in Go is that two different types are commonly used for representing text. &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;[]byte&lt;/code&gt;. A quick example is the &lt;a href=&#34;http://golang.org/pkg/regexp/#Regexp.FindAll&#34;&gt;regexp package&lt;/a&gt; which has functions for both &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;[]byte&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-is-the-difference:c3d0e20736b8b30967b0a5298a41fdb7&#34;&gt;What is the difference?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;string&lt;/code&gt; is immutable and &lt;code&gt;[]byte&lt;/code&gt; is mutable. Both can contain arbitrary bytes.&lt;/p&gt;

&lt;p&gt;The name &amp;ldquo;string&amp;rdquo; implies unicode text but this is not enforced. Operating on &lt;code&gt;string&lt;/code&gt; is like operating on &lt;code&gt;[]byte&lt;/code&gt;. You are working with bytes not characters.&lt;/p&gt;

&lt;p&gt;They are nearly identical and differ only in mutability. The &lt;a href=&#34;http://golang.org/pkg/strings/&#34;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://golang.org/pkg/bytes/&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; packages are nearly identical apart from the type that they use.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; If strings are just arbitrary bytes, then how do you work with characters?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; What you are thinking of as a character, Go calls a &lt;a href=&#34;http://golang.org/ref/spec#Rune_literals&#34;&gt;rune&lt;/a&gt;. One way to iterate the characters in a string is to use the &lt;code&gt;for...range&lt;/code&gt; loop. Range will parse the string as UTF-8 and iterate the runes. Read &lt;a href=&#34;http://golang.org/doc/effective_go.html#for&#34;&gt;the &lt;code&gt;for&lt;/code&gt; loop&lt;/a&gt; section of Effective Go for more information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;when-to-use-string:c3d0e20736b8b30967b0a5298a41fdb7&#34;&gt;When to use &lt;code&gt;string&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;Ask not when to use &lt;code&gt;string&lt;/code&gt; but rather, when to use &lt;code&gt;[]byte&lt;/code&gt;. Always start with &lt;code&gt;string&lt;/code&gt; and switch to &lt;code&gt;[]byte&lt;/code&gt; when justified.&lt;/p&gt;

&lt;h2 id=&#34;when-to-use-byte:c3d0e20736b8b30967b0a5298a41fdb7&#34;&gt;When to use &lt;code&gt;[]byte&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;[]byte&lt;/code&gt; when you need to make many changes to a string. Since &lt;code&gt;string&lt;/code&gt; is immutable, any change will allocate a new &lt;code&gt;string&lt;/code&gt;. You can get better performance by using &lt;code&gt;[]byte&lt;/code&gt; and avoiding the allocations.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C# perspective: &lt;code&gt;[]byte&lt;/code&gt; is to &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.text.stringbuilder(v=vs.110).aspx&#34;&gt;&lt;code&gt;System.StringBuilder&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;string&lt;/code&gt; is to &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.string(v=vs.110).aspx&#34;&gt;&lt;code&gt;System.String&lt;/code&gt;&lt;/a&gt; when it comes to performance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Even if your code isn&amp;rsquo;t directly manipulating the string, you may want to use &lt;code&gt;[]byte&lt;/code&gt; if you are using packages which require it so you can avoid the conversion.&lt;/p&gt;

&lt;p&gt;Converting to and from &lt;code&gt;[]byte&lt;/code&gt; is easy. Just remember that each conversion creates a copy of the value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s := &amp;quot;some string&amp;quot;
b := []byte(s) // convert string -&amp;gt; []byte
s2 := string(b) // convert []byte -&amp;gt; string
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Converting to/from &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;[]byte&lt;/code&gt; copies the entire value. Using lots of type conversions in your code is typically a warning sign that you need to reevaluate the types you are using. You want to minimize conversions both for performance and clean code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;more-about-strings:c3d0e20736b8b30967b0a5298a41fdb7&#34;&gt;More about strings&lt;/h2&gt;

&lt;p&gt;The Go blog has posted in detail about &lt;a href=&#34;http://blog.golang.org/strings&#34;&gt;strings, bytes, runes, and characters in Go&lt;/a&gt;. You should definitely read that post to fully understand the topic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Thanks to &lt;a href=&#34;https://twitter.com/mholt6&#34;&gt;@mholt6&lt;/a&gt; for reviewing the post and helping improve it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go 101: Methods on Pointers vs. Values</title>
      <link>http://joshua.poehls.me/2014/04/go-101-methods-on-pointers-vs-values</link>
      <pubDate>Mon, 14 Apr 2014 09:58:59 CDT</pubDate>
      <author>Joshua Poehls</author>
      <guid>http://joshua.poehls.me/2014/04/go-101-methods-on-pointers-vs-values</guid>
      <description>&lt;p&gt;Methods can be declared on both pointers and values. The difference is subtle but important.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Person struct {
     age int
}

// Method&#39;s receiver is the value, `Person`.
func (p Person) Age() int {
     return p.age
}

// Method&#39;s receiver is a pointer, `*Person`.
func (p *Person) SetAge(age int) {
     p.age = age
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In reality, you&amp;rsquo;d only define getter and setter functions like this if you needed to implement additional logic. In an example like this you&amp;rsquo;d just make the &lt;code&gt;Age&lt;/code&gt; field public.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is how you define getter and setter functions in Go. Notice that we defined the &lt;code&gt;Age()&lt;/code&gt; function on the value but &lt;code&gt;SetAge()&lt;/code&gt; on the pointer (i.e. &lt;code&gt;*Person&lt;/code&gt;). This is important.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Go always passes by value.&lt;/strong&gt; Function parameters are  always passed by copying them as opposed to passing a reference. (&lt;a href=&#34;http://golang.org/doc/faq#pass_by_value&#34;&gt;Read more.&lt;/a&gt;)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Even pointers are technically passed by value. The memory address is copied, the value it points to is &lt;em&gt;not&lt;/em&gt; copied.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is the &lt;em&gt;wrong&lt;/em&gt; way to define &lt;code&gt;SetAge&lt;/code&gt;. Let&amp;rsquo;s see what happens.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (p Person) SetAge(age int) {
     p.age = age
}

p := Person{}
p.SetAge(10)
fmt.Printf(&amp;quot;Age: %v&amp;quot;, p.Age()) // Age: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/CJZfqBrAIC&#34;&gt;&amp;#9654; Run it.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Notice that the output is &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;10&lt;/code&gt;? This is &amp;lsquo;pass by value&amp;rsquo; in action.&lt;/p&gt;

&lt;p&gt;Calling &lt;code&gt;p.SetAge(10)&lt;/code&gt; passes a copy of &lt;code&gt;p&lt;/code&gt; to the &lt;code&gt;SetAge&lt;/code&gt; function. &lt;code&gt;SetAge&lt;/code&gt; sets the &lt;code&gt;age&lt;/code&gt; property on the copy of &lt;code&gt;p&lt;/code&gt; that it received which is discarded after the function returns.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s do it the right way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (p *Person) SetAge(age int) {
     p.age = age
}

p := Person{}
p.SetAge(10)
fmt.Printf(&amp;quot;Age: %v&amp;quot;, p.Age()) // Age: 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/BbIlSUQBCr&#34;&gt;&amp;#9654; Run it.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My rule of thumb is this: declare the method on the pointer unless your struct is such that you don&amp;rsquo;t use pointers to it.&lt;/p&gt;

&lt;p&gt;Two reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Performance. Calling a method on a pointer will almost always be faster than copying the value. There may be cases wear the copy is faster but those are edge case.&lt;/li&gt;
&lt;li&gt;Consistency. It is common for at least one of your methods to need a pointer receiver and if any of the type&amp;rsquo;s methods are on the pointer then they all should be. &lt;em&gt;This recommendation is direct from &lt;a href=&#34;http://golang.org/doc/faq#methods_on_values_or_pointers&#34;&gt;the FAQ&lt;/a&gt;.&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/doc/faq#methods_on_values_or_pointers&#34;&gt;Read the FAQ&lt;/a&gt; &amp;ldquo;Should I define methods on values or pointers?&amp;rdquo; for more insight.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Thanks to the fine folks on reddit for suggesting some improvements.&lt;br /&gt;
&lt;a href=&#34;http://www.reddit.com/r/golang/comments/23060m/go_101_methods_on_pointers_vs_values/&#34;&gt;Join the discussion on reddit!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go 101: Constructors and Overloads</title>
      <link>http://joshua.poehls.me/2014/04/go-conventions-constructors-and-overloads</link>
      <pubDate>Fri, 11 Apr 2014 09:58:59 CDT</pubDate>
      <author>Joshua Poehls</author>
      <guid>http://joshua.poehls.me/2014/04/go-conventions-constructors-and-overloads</guid>
      <description>&lt;p&gt;Go doesn&amp;rsquo;t have constructors in the traditional sense. The convention is to make the zero value useful whenever possible.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Person struct {
     Age int
}

// These are equivalent.
// `p1` and `p2` are initialized to the zero value of Person.
// Neither of these are nil.
var p1 Person // type Person
p2 := Person{} // type Person

// You could also use `new` to allocate which returns a pointer
p3 := new(Person) // type *Person
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;It is most common to use the struct initializer. e.g. &lt;code&gt;p := Person{}&lt;/code&gt; or &lt;code&gt;p := &amp;amp;Person{}&lt;/code&gt; if you need the pointer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sometimes you want special initialization logic. If your type is named &lt;code&gt;Person&lt;/code&gt; then the convention would be create a function named &lt;code&gt;NewPerson&lt;/code&gt; that returns a pointer to an initialized &lt;code&gt;Person&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewPerson(int age) *Person {
     p := Person{age}
     return &amp;amp;p
}

myPerson := NewPerson(10) // type *Person
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple constructors can be implemented by having multiple initializer functions. Go doesn&amp;rsquo;t support function overloads so you will need to name your functions intelligently.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;time&amp;quot;

func NewPersonAge(int age) *Person {
     p := Person{age}
     return &amp;amp;p
}

func NewPersonBirthYear(int birthYear) *Person {
     p := Person{time.Now().Year() - birthYear}
     return &amp;amp;p
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://golang.org/doc/effective_go.html#composite_literals&#34;&gt;Read more&lt;/a&gt; in Effective Go.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Thanks to Joe Shaw for the comments! I&amp;rsquo;ve updated the article with his suggestions.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>